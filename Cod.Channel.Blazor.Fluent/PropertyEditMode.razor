@if (propertyValue is not string && propertyValue is System.Collections.IEnumerable children)
{
    foreach (var child in children)
    {
        if (child is IViewModel vm)
        {
            <div class="property-row">
                <div class="property-label">@Property.DisplayName</div>
                <div class="property-value"><StackEditView Data="vm" /></div>
            </div>
        }
    }
}
else if (Property.IsSubject)
{
    <div class="property-row property-row-subject">
        <div class="property-subject-value">
            @fieldDisplayValue
        </div>
    </div>
}
else
{
    <div class="property-row">
        <div class="property-label">@fieldDisplayName</div>
        <div class="property-value">
            @if (Property.Control == PropertyControl.Label)
            {
                <FluentLabel Typo="Typography.Body">@fieldDisplayValue</FluentLabel>
            }
            else if (Property.Control == PropertyControl.TextField)
            {
                <FluentTextField Name="@fieldName"
                                 @bind-Value:get="textBindValue"
                                 @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                 Required="@Property.IsRequired" />
                <FluentValidationMessage TValue="EditProperty" Field="@fieldIdentifier" />
            }
            else if (Property.Control == PropertyControl.NumberField)
            {
                @if (propertyValue is long lv)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="lv"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else if (propertyValue is ulong ulv)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="ulv"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else if (propertyValue is uint ui)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="ui"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else if (propertyValue is int i)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="i"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else if (propertyValue is short s)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="s"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else if (propertyValue is ushort us)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="us"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else if (propertyValue is decimal d)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="d"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else if (propertyValue is float f)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="f"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else if (propertyValue is double db)
                {
                    <FluentNumberField Name="@fieldName"
                                       @bind-Value:get="db"
                                       @bind-Value:set="(v) => Property.SetValue(ViewModel, v)"
                                       Required="@Property.IsRequired" />
                }
                else
                {
                    throw new InvalidOperationException($"Unsupported type for number field binding: {fieldName}");
                }
                <FluentValidationMessage TValue="EditProperty" Field="@fieldIdentifier" />
            }
            else if (Property.Control == PropertyControl.Dropdown)
            {
                <FluentSelect TOption="EditOption"
                              Name="@fieldName"
                              Items=@options
                              Multiple="@isMultipleSelect"
                              OptionText="@(i => i!.Text)"
                              OptionValue="@(i => i!.Value)"
                              OptionSelected="@(i => i!.IsSelected)"
                              SelectedOptionChanged="OnSelectedOptionChanged"
                              SelectedOptionsChanged="OnSelectedOptionsChanged"
                Required="@Property.IsRequired" />
            }
            else if (Property.Control == PropertyControl.Calendar && Property is EditDateTimeProperty p)
            {
                var kind = p.GetCalendarKind(ViewModel);
                @switch (kind)
                {
                    case CalendarKind.Day:
                        <FluentDatePicker Name="@fieldName"
                                          View="CalendarViews.Days"
                                          Required="@Property.IsRequired"
                                          @bind-Value="calendarBindValue" />
                        break;
                    case CalendarKind.Month:
                        <FluentDatePicker Name="@fieldName"
                                          View="CalendarViews.Months"
                                          Required="@Property.IsRequired"
                                          @bind-Value="calendarBindValue" />
                        break;
                    case CalendarKind.Year:
                        <FluentDatePicker Name="@fieldName"
                                          View="CalendarViews.Years"
                                          Required="@Property.IsRequired"
                                          @bind-Value="calendarBindValue" />
                        break;
                }
            }
        </div>
    </div>
}

@code {

    private string? fieldDisplayName => Property?.DisplayName;
    private object? fieldDisplayValue => ModelHelper.GetFieldDisplayValue(propertyValue);
    private string fieldName => Property.PropertyName;
    private Microsoft.AspNetCore.Components.Forms.FieldIdentifier fieldIdentifier
        => new FieldIdentifier(ViewModel, fieldName);
    private object? propertyValue => Property.GetValue(ViewModel);

    private string? textBindValue => fieldDisplayValue?.ToString();

    private bool isMultipleSelect => false;

    private IEnumerable<EditOption> options => (Property as EditOptionalProperty)?.GetOptions(ViewModel) ?? [];

    private DateTime? calendarBindValue
    {
        get
        {
            if (propertyValue == null)
            {
                return null;
            }

            if (propertyValue is DateTime dt)
            {
                return dt;
            }

            if (propertyValue is DateTimeOffset dto)
            {
                return dto.DateTime;
            }

            if (propertyValue is string str && DateTime.TryParse(str, out var parsedDate))
            {
                return parsedDate;
            }

            if (propertyValue is long timestamp)
            {
                return DateTimeOffsetExtensions.FromReverseUnixTimeMilliseconds(timestamp).DateTime;
            }

            if (propertyValue is DateOnly dateOnly)
            {
                return dateOnly.ToDateTime(TimeOnly.MinValue);
            }

            if (propertyValue is TimeOnly timeOnly)
            {
                return DateTime.Today.Add(timeOnly.ToTimeSpan());
            }

            throw new InvalidOperationException($"Unsupported type for calendar binding: {propertyValue.GetType()}");
        }
        set
        {
            if (value.HasValue)
            {
                if (Property.PropertyType == typeof(DateTime) || Property.PropertyType == typeof(DateTime?))
                {
                    Property.SetValue(ViewModel, value.Value);
                }
                else if (Property.PropertyType == typeof(DateTimeOffset) || Property.PropertyType == typeof(DateTimeOffset?))
                {
                    var dto = new DateTimeOffset(value.Value, TimeZoneInfo.Local.GetUtcOffset(value.Value));
                    Property.SetValue(ViewModel, dto);
                }
                else if (Property.PropertyType == typeof(long) || Property.PropertyType == typeof(long?))
                {
                    var dto = new DateTimeOffset(value.Value, TimeZoneInfo.Local.GetUtcOffset(value.Value));
                    var timestamp = dto.ToReverseUnixTimeMilliseconds();
                    Property.SetValue(ViewModel, timestamp);
                }
                else if (Property.PropertyType == typeof(DateOnly) || Property.PropertyType == typeof(DateOnly?))
                {
                    Property.SetValue(ViewModel, value.Value.Date);
                }
                else if (Property.PropertyType == typeof(TimeOnly) || Property.PropertyType == typeof(TimeOnly?))
                {
                    Property.SetValue(ViewModel, TimeOnly.FromDateTime(value.Value));
                }
                else
                {
                    throw new InvalidOperationException($"Unsupported type for calendar binding: {Property.PropertyType}");
                }
            }
        }
    }

    [Parameter]
    public required IViewModel ViewModel { get; set; }

    [Parameter]
    public required EditProperty Property { get; set; }

    private async Task OnSelectedOptionsChanged(IEnumerable<EditOption>? optionsChanged)
    {
        bool isDirty = false;
        if (isMultipleSelect)
        {
            if (optionsChanged != null)
            {
                foreach (var opt in optionsChanged)
                {
                    opt.OnSelected(true);
                    isDirty = true;
                }
            }

            foreach (var opt in options)
            {
                if (optionsChanged == null || !optionsChanged.Contains(opt))
                {
                    opt.OnSelected(false);
                    isDirty = true;
                }
            }
        }

        if (isDirty)
        {
            await ViewModel.RefreshAsync();
        }
    }
    private async Task OnSelectedOptionChanged(EditOption? optionChanged)
    {
        bool isDirty = false;
        if (!isMultipleSelect)
        {
            if (optionChanged != null)
            {
                optionChanged.OnSelected(true);
                isDirty = true;
            }

            foreach (var opt in options)
            {
                if (opt != optionChanged)
                {
                    opt.OnSelected(false);
                    isDirty = true;
                }
            }
        }

        if (isDirty)
        {
            await ViewModel.RefreshAsync();
        }
    }
}
